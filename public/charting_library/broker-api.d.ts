/**
 * Broker JS API for TradingView Charting Library (Trading Terminal only)
 * @packageDocumentation
 * @module Broker
 */
// Generated by dts-bundle-generator v7.0.0

export declare const enum ConnectionStatus {
	Connected = 1,
	Connecting = 2,
	Disconnected = 3,
	Error = 4
}
export declare const enum ConnectionType {
	Demo = 1,
	Real = 0
}
export declare const enum NotificationType {
	Error = 0,
	Success = 1
}
export declare const enum OrderStatus {
	Canceled = 1,
	Filled = 2,
	Inactive = 3,
	Placing = 4,
	Rejected = 5,
	Working = 6
}
export declare const enum OrderStatusFilter {
	All = 0,
	Canceled = 1,
	Filled = 2,
	Inactive = 3,
	Rejected = 5,
	Working = 6
}
export declare const enum OrderTicketFocusControl {
	LimitPrice = 1,
	StopPrice = 2,
	TakeProfit = 3,
	StopLoss = 4,
	Quantity = 5
}
export declare const enum OrderType {
	Limit = 1,
	Market = 2,
	Stop = 3,
	StopLimit = 4
}
export declare const enum ParentType {
	Order = 1,
	Position = 2,
	Trade = 3
}
export declare const enum PriceType {
	Limit = 1,
	Stop = 2
}
export declare const enum Side {
	Buy = 1,
	Sell = -1
}
export declare const enum StandardFormatterName {
	Date = "date",
	DateOrDateTime = "dateOrDateTime",
	Default = "default",
	Fixed = "fixed",
	VariablePrecision = "variablePrecision",
	FormatQuantity = "formatQuantity",
	FormatPrice = "formatPrice",
	FormatPriceForexSup = "formatPriceForexSup",
	IntegerSeparated = "integerSeparated",
	LocalDate = "localDate",
	LocalDateOrDateTime = "localDateOrDateTime",
	Percentage = "percentage",
	Pips = "pips",
	Profit = "profit",
	ProfitInInstrumentCurrency = "profitInInstrumentCurrency",
	Side = "side",
	PositionSide = "positionSide",
	Status = "status",
	Symbol = "symbol",
	Text = "text",
	Type = "type",
	MarginPercent = "marginPercent",
	Empty = "empty"
}
export declare enum OrderOrPositionMessageType {
	Information = "information",
	Warning = "warning",
	Error = "error"
}
export declare enum StopType {
	StopLoss = 0,
	TrailingStop = 1
}
/**
 * This is the generic type useful for declaring a nominal type,
 * which does not structurally matches with the base type and
 * the other types declared over the same base type
 *
 * Usage:
 * @example
 * type Index = Nominal<number, 'Index'>;
 * // let i: Index = 42; // this fails to compile
 * let i: Index = 42 as Index; // OK
 * @example
 * type TagName = Nominal<string, 'TagName'>;
 */
export declare type Nominal<T, Name extends string> = T & { /* eslint-disable-next-line jsdoc/require-jsdoc */
	[Symbol.species]: Name;
};
/** Column description for an account manager table */
export interface AccountManagerColumnBase<TFormatterName extends StandardFormatterName | FormatterName> {
	/** Column title. It will be displayed in the table's header row. */
	label: string;
	/**
	 * Horizontal alignment of the cell value. The default value is `left`.
	 *
	 * | alignment    |   description  |
	 * |--------------|----------------|
	 * | left         | It aligns the cell value to the left |
	 * | right        | It aligns the cell value to the right |
	 */
	alignment?: CellAlignment;
	/** Column id. Unique identifier of column. */
	id: string;
	/**
	 * Name of the formatter to be used for data formatting. It can be one of two types - `StandardFormatterName` or `FormatterName`. If `formatter` is not set, then the value is displayed as is.
	 * Formatter can be a default or a custom one.
	 *
	 * Default formatter names are listed in `StandardFormatterName` enumerator. If you want to use a custom formatter, you must typecast its name to `FormatterName` to confirm your confidence that you are using the correct name.
	 *
	 * Here is the list of default formatters:
	 *
	 * | name | description |
	 * | ---- | ----------- |
	 * | `StandardFormatterName.Date` | Displays the date or time. |
	 * | `StandardFormatterName.DateOrDateTime` | Displays the date or date and time. This formatter accepts an `{dateOrDateTime: number, hasTime: boolean}` object. If `hasTime` is set to `true` then the date and time are displayed. Otherwise only the date is displayed.|
	 * | `StandardFormatterName.Fixed` | Displays a number with 2 decimal places. |
	 * | `StandardFormatterName.FormatPrice` | Displays symbol's price. |
	 * | `StandardFormatterName.FormatQuantity` | Displays an integer or floating point quantity, separates thousands groups with a space. |
	 * | `StandardFormatterName.FormatPriceForexSup` | The same as `formatPrice`, but it makes the last character of the price superscripted. It works only if instrument type is set to `forex`.|
	 * | `StandardFormatterName.LocalDate` | Displays the local date or time. |
	 * | `StandardFormatterName.LocalDateOrDateTime` | The same as `StandardFormatterName.DateOrDateTime`, but it displays time in the local timezone. |
	 * | `StandardFormatterName.Pips` | Displays a number with 1 decimal place. |
	 * | `StandardFormatterName.Profit` | Displays profit in account currency. It also adds the `+` sign, separates thousands and changes the cell text color to red or green. |
	 * | `StandardFormatterName.ProfitInInstrumentCurrency` | Displays profit in instrument currency. It also adds the `+` sign, separates thousands and changes the cell text color to red or green. |
	 * | `StandardFormatterName.Side` | It is used to display the side: Sell or Buy. |
	 * | `StandardFormatterName.PositionSide` | It is used to display the position side: Short or Long. |
	 * | `StandardFormatterName.Status` | It is used to format the `status`. |
	 * | `StandardFormatterName.Symbol` | It is used for a symbol field. It displays `brokerSymbol`, but when you click on a symbol the chart changes according to the `symbol` field. |
	 * | `StandardFormatterName.Text` | Displays a text value. |
	 * | `StandardFormatterName.Type` | It is used to display the type of order: Limit/Stop/StopLimit/Market. |
	 * | `StandardFormatterName.VariablePrecision` | Displays a number with variable precision. |
	 */
	formatter?: TFormatterName;
	/**
	 * `dataFields` is an array with data object fields that is used to get the data to display in a column.
	 *
	 * The displayed value in the column will only change if one of the corresponding data object values change.
	 *
	 * If the `formatter` is not set, the displayed values will be space-separated in the column.
	 *
	 * If a `formatter` is specified, it will only get the specified values.
	 *
	 * Specify an empty array as the `dataFields` and the formatter will receive the entire data object.
	 *
	 * **Example**
	 * Example
	 *
	 * - If you have column with `dataFields` set as `['avgPrice', 'qty']`, then displayed value will update only if `avgPrice` or `qty` values of the data object have been changed.
	 * - If you have column with `dataFields` set as `[]`, then displayed value will update if some data object values have been changed.
	 */
	dataFields: TFormatterName extends StandardFormatterName ? StandardFormattersDependenciesMapping[TFormatterName] : string[];
	/**
	 * Data object key that is used for data sorting
	 *
	 * If `sortProp` is not provided, then the first element of the `dataFields` array will be used. If the `dataFields` array is empty, then column sorting will be unavailable.
	 */
	sortProp?: string;
	/** When set to `true` will prevent column sorting. */
	notSortable?: boolean;
	/** Tooltip string for the column. */
	help?: string;
	/**
	 * `highlightDiff` can be set with `StandardFormatterName.FormatPrice` and `StandardFormatterName.FormatPriceForexSup` formatters to highlight the changes of the field. If set to `true` then custom formatters will also get previous values.
	 */
	highlightDiff?: boolean;
	/** When set to `true` will prevent the column from hiding. */
	notHideable?: boolean;
	/** When set to `true` will hide the column by default */
	hideByDefault?: boolean;
	/** Key of the row object that is used to get the tooltip to display when hovering over a cell.
	 * The tooltip property refers to an object whose keys are property names and
	 * values are the corresponding tooltips.
	 */
	tooltipProperty?: string;
	/** If set to `true`, the first character of every word in the sentence in the column
	 * will be capitalized. The default value is `true`.
	 */
	isCapitalize?: boolean;
	/** When set to `true` any zero values will be hidden. Default is `true` */
	showZeroValues?: boolean;
}
export interface AccountManagerInfo {
	/** Name of the broker */
	accountTitle: string;
	/** Custom fields which will always be displayed above the pages. */
	summary: AccountManagerSummaryField[];
	/**
	 * Optional array to define custom formatters.
	 * Each description is an object with the following fields:
	 *
	 * 1. `name`: FormatterName
	 *     - Unique name of a formatter.
	 *
	 * 1. `formatText`: [TableFormatTextFunction](#tableformattextfunction)
	 *    -Function that is used for formatting of a cell value to `string`. Required because used to generate exported data.
	 *
	 * 1. `formatElement`: [CustomTableFormatElementFunction](#customtableformatelementfunction) | undefined
	 *     - Optional function that is used for formatting of a cell value to `string` or `HTMLElement`.
	 *
	 * If the `formatElement` function is provided, then only it will be used to format the displayed values, otherwise
	 * `formatText` will be used. If you need to only display `string` values it is better to use only `formatText` for performance reasons.
	 *
	 * **Example**
	 * ```ts
	 * {
	 *     name: 'closeButton' as FormatterName, // Typecast to FormatterName. Use constant in real code
	 *     formatText: () => '', // Returns an empty string because we don't need to display this in the exported data
	 *     formatElement: ({ values: [id] }: TableFormatterInputs<[id: string]>) => {
	 *         const button = document.createElement('button');
	 *
	 *         button.innerText = 'Close';
	 *
	 *         button.addEventListener('click', () => {
	 *             event.stopPropagation();
	 *
	 *             closePosition(id);
	 *         });
	 *
	 *         return button;
	 *     },
	 * }
	 * ```
	 */
	customFormatters?: CustomTableElementFormatter[];
	/** Columns description that you want to be displayed on the Orders page.
	 * You can display any field of an {@link Order}
	 * or add your own fields to an order object and display them.
	 */
	orderColumns: OrderTableColumn[];
	/** Optional sorting of the orders table. */
	orderColumnsSorting?: SortingParameters;
	/** History page will be displayed if it exists. All orders from previous sessions will be shown in the History. */
	historyColumns?: AccountManagerColumn[];
	/** Optional sorting of the history table. */
	historyColumnsSorting?: SortingParameters;
	/**
	 * You can display any field of a {@link Position}
	 * or add your own fields to a position object and display them.
	 */
	positionColumns?: AccountManagerColumn[];
	/**
	 * You can display any field of a {@link Trade}
	 * or add your own fields to a trade object and display them.
	 */
	tradeColumns?: AccountManagerColumn[];
	/** You can add new tabs in the Account Manager by using `pages`. Each tab is a set of tables. */
	pages: AccountManagerPage[];
	/** Optional list of statuses to be used in the orders filter. Default list is used if it hasn't been set. */
	possibleOrderStatuses?: OrderStatus[];
	/** Margin used */
	marginUsed?: IWatchedValue<number>;
	/**
	 * Optional function to create a custom context menu.
	 * @param contextMenuEvent - MouseEvent or TouchEvent object passed by a browser
	 * @param activePageActions - array of `ActionMetaInfo` items for the current page
	 * @returns `Promise` that is resolved with an array of `ActionMetaInfo`
	 */
	contextMenuActions?(contextMenuEvent: MouseEvent | TouchEvent, activePageActions: ActionMetaInfo[]): Promise<ActionMetaInfo[]>;
}
/** A description of an additional Account Manager tab. */
export interface AccountManagerPage {
	/** Unique identifier of a page */
	id: string;
	/** Page title. It is the tab name. */
	title: string;
	/** It is possible to display one or more tables in this tab. */
	tables: AccountManagerTable[];
}
/** Custom field that will always be shown above the pages of the Account manager */
export interface AccountManagerSummaryField {
	/** Text to display for the summary field */
	text: string;
	/** A WatchedValue object that can be used to read the state of field. */
	wValue: IWatchedValueReadonly<any>;
	/**
	 * Name of the formatter to be used for data formatting. If `formatter` is not
	 * set the value is displayed as is. Formatter can be a default or a custom one.
	 */
	formatter?: StandardFormatterName;
	/** Optional parameter which can be set to display the field by default. */
	isDefault?: boolean;
}
/**
 * Account Summary table meta-info
 * **NOTE**: make sure that you have a unique string `id` field in each row to identify it.
 */
export interface AccountManagerTable {
	/** Unique identifier of a table. */
	id: string;
	/** Optional title of a table. */
	title?: string;
	/** Table columns */
	columns: AccountManagerColumn[];
	/** Optional sorting of the table. If set, then the table will be sorted by these parameters, if the user has not enabled sorting by a specific column. */
	initialSorting?: SortingParameters;
	/** This delegate is used to watch the data changes and update the table.
	 * Pass new account manager data row by row to the `fire` method of the delegate.
	 */
	changeDelegate: ISubscription<(data: {}) => void>;
	/** Option flags for the table. */
	flags?: AccountManagerTableFlags;
	/**
	 * This function is used to request table data. It should return Promise (or Deferred) and resolve it with an array of data rows.
	 *
	 * Each row is an object. Keys of this object are column names with the corresponding values.
	 *
	 * There is a predefined field `isTotalRow` which can be used to mark a row that should be at the bottom of the table.
	 * @param paginationLastId - Last pagination id
	 */
	getData(paginationLastId?: string | number): Promise<{}[]>;
}
/** Boolean options for the account manager table */
export interface AccountManagerTableFlags {
	/** Does the table support pagination */
	supportPagination?: boolean;
}
export interface AccountMetainfo {
	/**
	 * Account ID
	 */
	id: AccountId;
	/**
	 * Account Name
	 */
	name: string;
	/**
	 * Currency
	 */
	currency?: string;
	/**
	 * Currency Sign (Prefix)
	 */
	currencySign?: string;
}
export interface ActionDescription {
	/** Displayed text for action */
	text?: "-" | string;
	/** Is a menu separator */
	separator?: boolean;
	/** Keyboard shortcut for the action. Displayed as hint text. */
	shortcut?: string;
	/** Tooltip text to be displayed when hovering over the action item. */
	tooltip?: string;
	/** Value of the checkbox. */
	checked?: boolean;
	/** Getter to retrieve the current checkbox value. */
	checkedStateSource?: () => boolean;
	/** Whether menu action represents a checkbox state. Set it to true if you need a checkbox. */
	checkable?: boolean;
	/** Whether the action is enabled. Set to false to disabled the action. */
	enabled?: boolean;
	/** External link (url) which will be opened upon clicking the menu item. */
	externalLink?: boolean;
	/**
	 * A string of SVG icon for an action. A string should be a string representation of SVG (not a path/URL).
	 */
	icon?: string;
}
/** Menu action which provides a callback function to be executed. Action is executed when user clicks the item. */
export interface ActionDescriptionWithCallback extends ActionDescription {
	/** Action to be executed when user clicks the menu item. */
	action: (a?: ActionDescription) => void;
}
export interface BaseInputFieldValidatorResult {
	/** Is the base input value valid */
	valid: boolean;
}
export interface BracketOrder extends BracketOrderBase, CustomFields {
}
export interface BracketOrderBase extends PlacedOrderBase {
	/** If order is a bracket then this should contain base order/position id. */
	parentId: string;
	/** Type of the bracket's parent */
	parentType: ParentType;
}
export interface Brackets {
	/** Stop loss */
	stopLoss?: number;
	/** Take Profit */
	takeProfit?: number;
	/** Trailing Stop Pips */
	trailingStopPips?: number;
}
export interface BrokerConfigFlags {
	/**
	 * Display broker symbol name in the symbol search. You may usually want to disable it if broker symbols are the same or you are using internal numbers as broker symbol names.
	 * @default true
	 */
	supportDisplayBrokerNameInSymbolSearch?: boolean;
	/**
	 * This flag can be used to change "Amount" to "Quantity" in Order Ticket.
	 * @default false
	 */
	showQuantityInsteadOfAmount?: boolean;
	/**
	 * Broker supports brackets (take profit and stop loss) for orders.
	 * @default false
	 */
	supportOrderBrackets?: boolean;
	/**
	 * Broker supports trailing stop orders.
	 * If this flag is set to `true`, then the chart displays trailing stop orders and a user can place a trailing stop order using Order Ticket.
	 * @default false
	 */
	supportTrailingStop?: boolean;
	/**
	 * Broker supports positions.
	 * If it is set to `false`, the Positions tab in the Account Manager will be hidden.
	 * @default true
	 */
	supportPositions?: boolean;
	/**
	 * Broker supports brackets (take profit and stop loss orders) for positions.
	 * If this flag is set to `true` the Chart will display an Edit button for positions and add `Edit position...` to the context menu of a position.
	 * @default false
	 */
	supportPositionBrackets?: boolean;
	/**
	 * Broker supports brackets for trades (take profit and stop loss orders).
	 * If this flag is set to `true` the Chart will display an Edit button for trades (individual positions) and add `Edit position...` to the context menu of a trade.
	 * @default false
	 */
	supportTradeBrackets?: boolean;
	/**
	 * Broker supports individual positions (trades).
	 * If it is set to `true`, there will be two tabs in the Account Manager - Individual Positions and Net Positions.
	 * @default false
	 */
	supportTrades?: boolean;
	/**
	 * Broker supports closing of a position.
	 * If it is not supported by broker, Chart will have the close button, but it will place a closing order.
	 * @default false
	 */
	supportClosePosition?: boolean;
	/**
	 * Individual positions (trades) can be closed.
	 * @default false
	 */
	supportCloseTrade?: boolean;
	/**
	 * Using this flag you can disable existing order's price modification.
	 * @default true
	 */
	supportModifyOrderPrice?: boolean;
	/**
	 * Using this flag you can disable existing order's quantity modification.
	 * @default true
	 */
	supportEditAmount?: boolean;
	/**
	 * Using this flag you can disable existing order's brackets modification. If you set it to `false`,
	 * additional fields will be disabled in Order Ticket on the chart,
	 * and 'Modify' button will be hidden from the chart and in the Account Manager.
	 * @default true
	 */
	supportModifyBrackets?: boolean;
	/**
	 * Level2 data is used for DOM widget. `subscribeDepth` and `unsubscribeDepth` should be implemented.
	 * @default false
	 */
	supportLevel2Data?: boolean;
	/**
	 * Does broker support Depth of Market.
	 * @default false
	 */
	supportDOM?: boolean;
	/**
	 * Supporting multiposition prevents creating the default implementation for a reversing position.
	 * @default false
	 */
	supportMultiposition?: boolean;
	/**
	 * Broker provides PL for a position. If the broker calculates profit/loss by itself it should call `plUpdate` as soon as PL is changed.
	 * Otherwise Chart will calculate PL as a difference between the current trade and an average price of the position.
	 * @default true
	 */
	supportPLUpdate?: boolean;
	/**
	 * Broker supports reversing of a position.
	 * If it is not supported by broker, the reverse position button will be hidden.
	 * @default false
	 */
	supportReversePosition?: boolean;
	/**
	 * Broker natively supports reversing of a position.
	 * If it is not natively supported by broker, Chart will place a reversing order.
	 * @default false
	 */
	supportNativeReversePosition?: boolean;
	/**
	 * This flag adds market orders type to Order Ticket.
	 * @default true
	 */
	supportMarketOrders?: boolean;
	/**
	 * This flag adds limit orders type to Order Ticket.
	 * @default true
	 */
	supportLimitOrders?: boolean;
	/**
	 * This flag adds stop orders type to Order Ticket.
	 * @default true
	 */
	supportStopOrders?: boolean;
	/**
	 * This flag adds stop-limit orders type to Order Ticket.
	 * @default false
	 */
	supportStopLimitOrders?: boolean;
	/**
	 * Does broker support demo live switcher.
	 * @default true
	 */
	supportDemoLiveSwitcher?: boolean;
	/**
	 * Using this flag you can disable brackets for market orders.
	 * @default true
	 */
	supportMarketBrackets?: boolean;
	/**
	 * Broker supports symbol search
	 * @default false
	 */
	supportSymbolSearch?: boolean;
	/**
	 * Using this flag you can enable modification of the duration of the existing order.
	 * @default false
	 */
	supportModifyDuration?: boolean;
	/**
	 * Broker supports modifying trailing stop orders.
	 * @default true
	 */
	supportModifyTrailingStop?: boolean;
	/**
	 * Broker supports margin.
	 * If the broker supports margin it should call `marginAvailableUpdate` ({@link IBrokerConnectionAdapterHost.marginAvailableUpdate}) when the Trading Terminal subscribes using `subscribeMarginAvailable` ({@link IBrokerWithoutRealtime.subscribeMarginAvailable}).
	 * @default false
	 */
	supportMargin?: boolean;
	/**
	 * Calculate Profit / Loss using last value.
	 * @default false
	 */
	calculatePLUsingLast?: boolean;
	/**
	 * Broker provides the estimated commission, fees, margin and other order information before placing the order without actually placing it.
	 * @default false
	 */
	supportPlaceOrderPreview?: boolean;
	/**
	 * Broker provides the estimated commission, fees, margin and other order information before modifying the order without actually modifying it.
	 * @default false
	 */
	supportModifyOrderPreview?: boolean;
	/**
	 * Broker supports leverage. If the flag is set to `true`, broker will calculate leverage using `leverageInfo` ({@link IBrokerWithoutRealtime.leverageinfo}) method.
	 * @default false
	 */
	supportLeverage?: boolean;
	/**
	 * Broker supports leverage button. If the flag is set to `true`, a leverage input field will appear in Order Ticket. Click on the input field will activate a dedicated Leverage Dialog.
	 * @default true
	 */
	supportLeverageButton?: boolean;
	/**
	 * Broker supports orders history. If it is set to `true`, there will be an additional tab in the Account Manager - Orders History.
	 * The `ordersHistory` method should be implemented. It should return a list of orders with the `filled`, `cancelled` and `rejected` statuses from previous trade sessions.
	 * @default false
	 */
	supportOrdersHistory?: boolean;
	/**
	 * Using this flag you can disable adding brackets to the existing order.
	 * @default true
	 */
	supportAddBracketsToExistingOrder?: boolean;
	/**
	 * Used for crypto currencies only. Allows to get crypto balances for an account. Balances are displayed as the first table of the Account Summary tab.
	 * @default false
	 */
	supportBalances?: boolean;
	/**
	 * Closing a position cancels its brackets.
	 * @default false
	 */
	closePositionCancelsOrders?: boolean;
	/**
	 * `Stop Loss` and `Take Profit` are added or removed only together.
	 * @default false
	 */
	supportOnlyPairPositionBrackets?: boolean;
	/**
	 * Whether the account is used to exchange(trade) crypto currencies.
	 * This flag switches Order Ticket to the Crypto Exchange mode. It adds second currency quantity control, currency labels etc.
	 * @default false
	 */
	supportCryptoExchangeOrderTicket?: boolean;
	/**
	 * With this flag you can show a checkbox to disable the confirmation dialog display
	 * @default false
	 */
	supportConfirmations?: boolean;
	/**
	 * Using this flag you can display PL in instrument currency.
	 * @default false
	 */
	positionPLInInstrumentCurrency?: boolean;
	/**
	 * Does broker support partial position closing
	 * @default false
	 */
	supportPartialClosePosition?: boolean;
	/**
	 * Does broker support partial trade closing
	 * @default false
	 */
	supportPartialCloseTrade?: boolean;
	/**
	 * Cancelling a bracket (take profit or stop loss) cancels its pair.
	 * @default false
	 */
	supportCancellingBothBracketsOnly?: boolean;
	/**
	 * Does broker support crypto brackets
	 * @default false
	 */
	supportCryptoBrackets?: boolean;
	/**
	 * Using this flag you can show/hide the `Notifications log` tab in the account manager.
	 * @default true
	 */
	showNotificationsLog?: boolean;
	/**
	 * Whether stop orders should behave like Market-if-touched in both directions.
	 * Enabling this flag prevents the check of stop price direction from the stop limit Order Ticket.
	 * @default false
	 */
	supportStopOrdersInBothDirections?: boolean;
	/**
	 * Enabling this flag prevents the check of stop price direction from the stop limit Order Ticket.
	 */
	supportStopLimitOrdersInBothDirections?: boolean;
	/**
	 * Broker supports executions.
	 * If this flag is set to `true` the Chart will display executions.
	 * @default false
	 */
	supportExecutions?: boolean;
	/**
	 * Does broker support modifying order type
	 * @default false
	 */
	supportModifyOrderType?: boolean;
	/**
	 * Trading account requires closing of trades in FIFO order.
	 * @default false
	 */
	requiresFIFOCloseTrades?: boolean;
	/**
	 * @deprecated
	 */
	supportBrackets?: boolean;
	/**
	 * Use supportModifyOrderPrice, supportEditAmount and supportModifyBrackets instead.
	 * @deprecated
	 */
	supportModifyOrder?: boolean;
}
export interface BrokerCustomUI {
	/**
	 * Shows standard Order Ticket to create or modify an order and executes handler if Buy/Sell/Modify is pressed.
	 * @param  {OrderTemplate|Order} order - order to be placed or modified
	 * @param  {OrderTicketFocusControl} focus? - Control to focus on when dialog is opened
	 */
	showOrderDialog?: (order: OrderTemplate | Order, focus?: OrderTicketFocusControl) => Promise<boolean>;
	/**
	 * Shows the Position Dialog
	 * @param  {Position|Trade} position - position to be placed or modified
	 * @param  {Brackets} brackets - brackets for the position
	 * @param  {OrderTicketFocusControl} focus? - Control to focus on when dialog is opened
	 */
	showPositionDialog?: (position: Position | Trade, brackets: Brackets, focus?: OrderTicketFocusControl) => Promise<boolean>;
	/**
	 * Shows a confirmation dialog and executes handler if YES/OK is pressed.
	 * @param  {Order} order - order to be cancelled
	 */
	showCancelOrderDialog?: (order: Order) => Promise<boolean>;
	/**
	 * Shows the Close Position Dialog.
	 * @param  {Position} position - position to be closed
	 */
	showClosePositionDialog?: (position: Position) => Promise<boolean>;
}
export interface ChangeAccountSolution {
	/** id of a sub-account suitable for trading the symbol */
	changeAccount: AccountId;
}
export interface ChangeSymbolSolution {
	/** the symbol suitable for trading with current sub-account */
	changeSymbol: string;
}
export interface CheckboxFieldMetaInfo extends CustomFieldMetaInfoBase {
	/** @inheritDoc */
	inputType: "Checkbox";
	/** @inheritDoc */
	value: boolean;
	/** Does the field support modification */
	supportModify?: boolean;
	/** Help message for the field */
	help?: string;
}
export interface CryptoBalance {
	/** Symbol */
	symbol: string;
	/** Total balance */
	total: number;
	/** Available balance */
	available: number;
	/** Reserved balance */
	reserved?: number;
	/** Balance value */
	value?: number;
	/** Balance value's currency */
	valueCurrency?: string;
	/** Long name of Crypto */
	longName?: string;
	/** Bitcoin value of balance */
	btcValue?: number;
}
export interface CustomComboBoxItem {
	/** Combo box item text */
	text: string;
	/** Combo box item value */
	value: string;
}
export interface CustomComboBoxMetaInfo extends CustomInputFieldMetaInfo {
	/** @inheritDoc */
	inputType: "ComboBox";
	/** Items for the combo box input field */
	items: CustomComboBoxItem[];
}
export interface CustomFieldMetaInfoBase {
	/** Type of the input field */
	inputType: string;
	/** Input field ID */
	id: string;
	/** Title for the input field */
	title: string;
	/** Value of the field */
	value?: any;
	/** Should the input field value be saved to settings */
	saveToSettings?: boolean;
}
/**
 * Custom fields to be added to an object.
 */
export interface CustomFields {
	/** Custom field */
	[key: string]: any;
}
export interface CustomInputFieldMetaInfo extends CustomFieldMetaInfoBase {
	/** Prevent modification */
	preventModify?: boolean;
	/** Placeholder string for the field */
	placeHolder?: string;
	/** Validator function for the field */
	validator?: InputFieldValidator;
	/** Additional custom information */
	customInfo?: any;
}
/**
 * An object that contains the results of broker specific user inputs (for example a digital signature).
 */
export interface CustomInputFieldsValues {
	[fieldId: string]: TextWithCheckboxValue | boolean | string | any;
}
export interface CustomTableElementFormatter<T extends TableFormatterInputValues = TableFormatterInputValues> {
	/** Custom formatter name */
	name: FormatterName;
	/** Formatter to generate HTML element */
	formatElement?: CustomTableFormatElementFunction<T>;
	/** Formatter to generate text. Return an empty string if you don't need to display this */
	formatText: TableFormatTextFunction<T>;
}
/**
 * Depth of Market (Order Book) Data
 */
export interface DOMData {
	/**
	 * Whether the Depth of Market data is a snapshot (has the full set of depth data).
	 * - If `true` then the data contains the full set of depth data.
	 * - If `false` then data only contains updated levels.
	 */
	snapshot: boolean;
	/** Ask order levels (must be sorted by `price` in ascending order) */
	asks: DOMLevel[];
	/** Bid order levels (must be sorted by `price` in ascending order) */
	bids: DOMLevel[];
}
/**
 * Depth of Market Level
 */
export interface DOMLevel {
	/** Price for DOM level */
	price: number;
	/** Volume for DOM level */
	volume: number;
}
export interface DefaultContextMenuActionsParams {
}
export interface DefaultDropdownActionsParams {
	/** Show trading properties */
	tradingProperties?: boolean;
	/** Restore confirmations */
	restoreConfirmations?: boolean;
}
export interface ErrorFormatterParseResult extends FormatterParseResult {
	/** Optional message when there's an error while parsing */
	error?: string;
	/** @inheritDoc */
	res: false;
}
/**
 * Describes a single execution. Execution is a mark on a chart that displays trade information.
 */
export interface Execution extends CustomFields {
	/** Symbol name */
	symbol: string;
	/** Execution price */
	price: number;
	/** Execution Quantity */
	qty: number;
	/** Execution Side */
	side: Side;
	/** Time (unix timestamp in milliseconds) */
	time: number;
	/** Commission amount for executed trade */
	commission?: number;
	/** Net amount for executed trade */
	netAmount?: number;
}
export interface FormatterParseResult {
	/** Returns if the formatter support parsing */
	res: boolean;
}
export interface IBoxedValue<T> extends IBoxedValueReadOnly<T> {
	/**
	 * Set boxed value
	 * @param  {T} value - value to be set
	 */
	setValue(value: T): void;
}
export interface IBoxedValueReadOnly<T> {
	/** Value */
	value(): T;
}
export interface IBrokerCommon {
	/**
	 * Chart can have a sub-menu `Trading` in the context menu. This method should return an array of {@link ActionMetaInfo} elements, each of them representing one context menu item.
	 * @param  {TradeContext} context - context object passed by a browser
	 * @param  {DefaultContextMenuActionsParams} options? - default options for the context menu action parameters
	 */
	chartContextMenuActions(context: TradeContext, options?: DefaultContextMenuActionsParams): Promise<ActionMetaInfo[]>;
	/**
	 * This function is required for the Floating Trading Panel.
	 * The ability to trade via the panel depends on the result of this function: `true` or `false`.
	 * You don't need to implement this method if all symbols can be traded.
	 *
	 * If you want to show a custom message with the reason why the symbol cannot be traded then you can return an object `IsTradableResult`.
	 * @param  {string} symbol - symbol identifier
	 */
	isTradable(symbol: string): Promise<boolean | IsTradableResult>;
	/**
	 * Connection status for the Broker API.
	 *
	 * You don't need to return values other than `1` (`Connected`) typically since the broker is already connected when you create the widget.
	 * You can use it if you want to display a spinner in the bottom panel while the data is being loaded.
	 */
	connectionStatus(): ConnectionStatus;
	/**
	 * Called by Trading Terminal to request orders
	 */
	orders(): Promise<Order[]>;
	/**
	 * This method is called by the Trading Terminal to request orders history.
	 * It is expected that returned orders will have a final status (`rejected`, `filled`, `cancelled`).
	 *
	 * This method is optional. If you don't support orders history, please set `supportOrdersHistory` flag to `false`.
	 */
	ordersHistory?(): Promise<Order[]>;
	/**
	 * Called by Trading Terminal to request positions
	 */
	positions?(): Promise<Position[]>;
	/**
	 * Called by Trading Terminal to request trades
	 */
	trades?(): Promise<Trade[]>;
	/**
	 * Called by Trading Terminal to request executions for the specified symbol
	 * @param  {string} symbol - symbol identifier
	 */
	executions(symbol: string): Promise<Execution[]>;
	/**
	 * Called by the internal Order dialog, DOM panel, and floating trading panel to get symbol information.
	 * @param  {string} symbol - symbol identifier
	 */
	symbolInfo(symbol: string): Promise<InstrumentInfo>;
	/**
	 * This function should return the information that will be used to build an Account manager.
	 */
	accountManagerInfo(): AccountManagerInfo;
	/**
	 * Provide a custom price formatter for the specified symbol.
	 * @param  {string} symbol - symbol identifier
	 * @param  {boolean} alignToMinMove - align formatted number to the minimum movement amount of the symbol
	 */
	formatter?(symbol: string, alignToMinMove: boolean): Promise<INumberFormatter>;
	/**
	 * Provide a custom spread formatter for the specified symbol.
	 * @param  {string} symbol - symbol identifier
	 */
	spreadFormatter?(symbol: string): Promise<INumberFormatter>;
	/**
	 * Provide a custom quantity formatter for the specified symbol.
	 * @param  {string} symbol - symbol identifier
	 */
	quantityFormatter?(symbol: string): Promise<INumberFormatter>;
	/**
	 * Implement this method if you use the standard Order dialog and want to customize it.
	 *
	 * Use the `symbol` parameter to return customization options for a particular symbol.
	 * @param  {string} symbol - symbol identifier
	 */
	getOrderDialogOptions?(symbol: string): Promise<OrderDialogOptions | undefined>;
	/**
	 * Implement this method if you want to customize the position dialog.
	 */
	getPositionDialogOptions?(): PositionDialogOptions | undefined;
}
export interface IBrokerConnectionAdapterFactory {
	/** Creates a Delegate object */
	createDelegate<T extends Function>(): IDelegate<T>;
	/** Creates a WatchedValue object */
	createWatchedValue<T>(value?: T): IWatchedValue<T>;
	/**
	 * Creates a price formatter.
	 * @param priceScale - defines the number of decimal places. It is `10^number-of-decimal-places`. If a price is displayed as `1.01`, `pricescale` is `100`; If it is displayed as `1.005`, `pricescale` is `1000`.
	 * @param minMove - the amount of price precision steps for 1 tick. For example, since the tick size for U.S. equities is `0.01`, `minmov` is 1. But the price of the E-mini S&P futures contract moves upward or downward by `0.25` increments, so the `minmov` is `25`.
	 * @param fractional - for common prices is `false` or it can be skipped.
	 * @param minMove2 - for common prices is `0` or it can be skipped.
	 * @param variableMinTick - for common prices is string (for example, `0.01 10 0.02 25 0.05`) or it can be skipped.
	 *
	 * Example:
	 * 1. Typical stock with `0.01` price increment: `minmov = 1, pricescale = 100, minmove2 = 0`.
	 * 2. If `minmov = 1, pricescale = 100, minmove2 = 0, variableMinTick = "0.01 10 0.02 25 0.05"`:
	 *
	 * - for `price = 9`: `minmov = 1, pricescale = 100, minmove2 = 0`.
	 * - for `price = 13`: `minmov = 2, pricescale = 100, minmove2 = 0`.
	 * - for `price = 27`: `minmov = 5, pricescale = 100, minmove2 = 0`.
	 *
	 * For more information on fractional prices, see this [article](https://www.tradingview.com/charting-library-docs/latest/connecting_data/Symbology#price-format)
	 */
	createPriceFormatter(priceScale?: number, minMove?: number, fractional?: boolean, minMove2?: number, variableMinTick?: string): IPriceFormatter;
}
/**
 * Trading Host is an API for interaction between the Broker API and the Chart Trading Subsystem.
 * Its main purpose is to exchange information between our charts and your trading adapter.
 */
export interface IBrokerConnectionAdapterHost {
	/** Broker Connection Adapter Factory object */
	factory: IBrokerConnectionAdapterFactory;
	/**
	 * Generates and returns the default value formatter for the symbol
	 * @param  {string} symbol - symbol identifier
	 * @param  {boolean} alignToMinMove - whether the formatted number should be aligned to minimum movement for the symbol
	 */
	defaultFormatter(symbol: string, alignToMinMove: boolean): Promise<INumberFormatter>;
	/**
	 * Generates and returns a number formatter with the desired decimal places
	 * @param  {number} decimalPlaces? - decimal places
	 */
	numericFormatter(decimalPlaces: number): Promise<INumberFormatter>;
	/**
	 * Generates and returns a quantity formatter with the desired decimal places
	 * @param  {number} decimalPlaces? - decimal places
	 */
	quantityFormatter(decimalPlaces?: number): Promise<INumberFormatter>;
	/**
	 * Provides default buy/sell, show properties actions to be returned as a default by {@link IBrokerCommon.chartContextMenuActions}.
	 * @param  {TradeContext} context - trade context
	 * @param  {DefaultContextMenuActionsParams} params? - optional parameters
	 */
	defaultContextMenuActions(context: TradeContext, params?: DefaultContextMenuActionsParams): Promise<ActionMetaInfo[]>;
	/**
	 * Provides default dropdown list of actions. You can use default actions in {@link IBrokerConnectionAdapterHost.setButtonDropdownActions}
	 * @param  {Partial<DefaultDropdownActionsParams>} options? - options for the dropdown menu actions
	 */
	defaultDropdownMenuActions(options?: Partial<DefaultDropdownActionsParams>): ActionMetaInfo[];
	/** Returns whether the buy/sell buttons are visible or not. */
	sellBuyButtonsVisibility(): IWatchedValue<boolean> | null;
	/** Returns whether DOM Panel is visible or not. */
	domPanelVisibility(): IWatchedValue<boolean> | null;
	/** Returns whether the order panel is visible or not. */
	orderPanelVisibility(): IWatchedValue<boolean> | null;
	/** Returns if orders can be sent to the broker without showing the order ticket. */
	silentOrdersPlacement(): IWatchedValue<boolean>;
	/**
	 * Patch changes into the current broker configuration
	 * @param  {Partial<BrokerConfigFlags>} config - partial configuration changes to apply
	 */
	patchConfig(config: Partial<BrokerConfigFlags>): void;
	/**
	 * Set expiration durations
	 * @param  {OrderDurationMetaInfo[]} durations - Expiration options for orders
	 */
	setDurations(durations: OrderDurationMetaInfo[]): void;
	/**
	 * Call this method to notify the chart that it needs to update information after an order is added or changed.
	 * @param  {Order} order - order which was added or changed
	 */
	orderUpdate(order: Order): void;
	/**
	 * Call this method when an order is not changed, but the fields that you added to the order object to display in the Account Manager have changed.
	 * It should be used only if you want to display custom fields in the Account Manager.
	 * @param  {string} id - order id
	 * @param  {Partial<Order>} orderChanges - changes made to the order object
	 */
	orderPartialUpdate(id: string, orderChanges: Partial<Order>): void;
	/**
	 * Call this method when a position is added or changed.
	 * @param  {Position} position - position which was added or changed
	 * @param  {boolean} isHistoryUpdate? - whether the change is a history update
	 */
	positionUpdate(position: Position, isHistoryUpdate?: boolean): void;
	/**
	 * Call this method when a position is not changed, but the fields that you added to the position object to display in the Account Manager have changed.
	 * It should be used only if you want to display custom fields in the Account Manager.
	 * @param  {string} id - id of the position
	 * @param  {Partial<Position>} positionChanges - changes to the position object
	 */
	positionPartialUpdate(id: string, positionChanges: Partial<Position>): void;
	/**
	 * Call this method when a trade is added or changed.
	 * @param  {Trade} trade - updated trade
	 * @param  {boolean} isHistoryUpdate? - whether the change is a history update
	 */
	tradeUpdate(trade: Trade, isHistoryUpdate?: boolean): void;
	/**
	 * Call this method when a trade has not changed, but fields that you added to the trade object to display in the Account Manager have changed.
	 * @param  {string} id - id of the updated trade
	 * @param  {Partial<Trade>} tradeChanges - changes to the trade object
	 */
	tradePartialUpdate(id: string, tradeChanges: Partial<Trade>): void;
	/**
	 * Call this method when an execution is added.
	 * @param  {Execution} execution - execution which was added
	 */
	executionUpdate(execution: Execution): void;
	/**
	 * Call this method when user account has been changed synchronously. The terminal will re-request all displayed information.
	 */
	currentAccountUpdate(): void;
	/**
	 * Trading quote realtime update
	 * @param  {string} symbol - symbol identifier
	 * @param  {TradingQuotes} data - realtime updated data for the symbol quotes
	 */
	realtimeUpdate(symbol: string, data: TradingQuotes): void;
	/**
	 * Call this method when a broker connection has received a PL update. This method should be used when `supportPLUpdate` flag is set in `configFlags`.
	 * @param  {string} positionId - id of the position
	 * @param  {number} pl - updated profit / loss value
	 */
	plUpdate(positionId: string, pl: number): void;
	/**
	 * Call this method when a broker connection has a `pipValue` update.
	 * The library subscribes to `pipValue` updates using {@link IBrokerWithoutRealtime.subscribePipValue}.
	 * @param  {string} symbol - symbol with updated pip values
	 * @param  {PipValues} pipValues - updated pip values
	 */
	pipValueUpdate(symbol: string, pipValues: PipValues): void;
	/**
	 * Call this method when a broker connection has received a trade PL update.
	 * @param  {string} tradeId - id of the trade
	 * @param  {number} pl - updated profit / loss for the trade
	 */
	tradePLUpdate(tradeId: string, pl: number): void;
	/**
	 * Call this method when a broker connection has received an equity update. This method is required by the standard Order Dialog to calculate risks.
	 * @param  {number} equity - updated equity
	 */
	equityUpdate(equity: number): void;
	/**
	 * Call this method when a broker connection has received a margin available update.
	 * This method is required by the standard Order Dialog to display the margin meter.
	 * This method should be used when `supportMargin` flag is set in `configFlags`.
	 * The Trading Terminal subscribes to margin available updates using {@link IBrokerWithoutRealtime.subscribeMarginAvailable}.
	 * @param  {number} marginAvailable - updated available margin
	 */
	marginAvailableUpdate(marginAvailable: number): void;
	/**
	 * Call this method when a broker connection has received a balance update.
	 * This method is required by the crypto Order Dialog.
	 * It should be implemented when `supportBalances` flag is set in `configFlags`.
	 * @param  {string} symbol - symbol id
	 * @param  {CryptoBalance} balance - updated crypto balance
	 */
	cryptoBalanceUpdate(symbol: string, balance: CryptoBalance): void;
	/**
	 * Update the Depth of Market for the specified symbol
	 * @param  {string} symbol - symbol identifier
	 * @param  {DOMData} equity - Depth of market data
	 */
	domeUpdate(symbol: string, equity: DOMData): void;
	/**
	 * Shows the order dialog
	 * @param  {T extends PreOrder} order - order to show in the dialog
	 * @param  {OrderTicketFocusControl} focus? - input control to focus on when dialog is opened
	 */
	showOrderDialog?<T extends PreOrder>(order: T, focus?: OrderTicketFocusControl): Promise<boolean>;
	/**
	 * Shows notification message
	 * @param  {string} title - notification title
	 * @param  {string} text - notification content
	 * @param  {NotificationType} notificationType? - type of notification (default: NotificationType.Error)
	 */
	showNotification(title: string, text: string, notificationType?: NotificationType): void;
	/**
	 * Shows the cancel order dialog for specified order
	 * @param  {string} orderId - id of order to potentially cancel
	 * @param  {()=>Promise<void>} handler - cancel order confirmation handler (called when order should be cancelled)
	 */
	showCancelOrderDialog(orderId: string, handler: () => Promise<void>): Promise<void>;
	/**
	 * Shows the cancel order dialog for multiple orders
	 * @param  {string} symbol - symbol for which to cancel orders
	 * @param  {Side} side - side of the order
	 * @param  {number} qty - quantity of the order
	 * @param  {()=>Promise<void>} handler - cancel orders confirmation handler (called when orders should be cancelled)
	 */
	showCancelMultipleOrdersDialog(symbol: string, side: Side, qty: number, handler: () => Promise<void>): Promise<void>;
	/**
	 * Shows the cancel brackets dialog
	 * @param  {string} orderId - id of order
	 * @param  {()=>Promise<void>} handler - cancel brackets confirmation handler (called when brackets should be cancelled)
	 */
	showCancelBracketsDialog(orderId: string, handler: () => Promise<void>): Promise<void>;
	/**
	 * Shows the cancel brackets dialog for multiple brackets
	 * @param  {string} orderId - id of order
	 * @param  {()=>Promise<void>} handler - cancel brackets confirmation handler (called when brackets should be cancelled)
	 */
	showCancelMultipleBracketsDialog(orderId: string, handler: () => Promise<void>): Promise<void>;
	/**
	 * Shows reverse position dialog
	 * @param  {string} position - position to be reversed
	 * @param  {()=>Promise<boolean>} handler - reverse position confirmation handler (called when the position should be reversed)
	 */
	showReversePositionDialog(position: string, handler: () => Promise<boolean>): Promise<boolean>;
	/**
	 * Shows the position brackets dialog
	 * @param  {Position|Trade} position - position or trade
	 * @param  {Brackets} brackets - brackets for the position or trade
	 * @param  {OrderTicketFocusControl} focus - input control to focus on when dialog is opened
	 */
	showPositionBracketsDialog(position: Position | Trade, brackets: Brackets, focus: OrderTicketFocusControl): Promise<boolean>;
	/**
	 * Bottom Trading Panel has a button with a list of dropdown items. This method can be used to replace existing items.
	 * @param  {ActionMetaInfo[]} descriptions - Descriptions for the dropdown items.
	 */
	setButtonDropdownActions(descriptions: ActionMetaInfo[]): void;
	/**
	 * Activate bottom widget
	 */
	activateBottomWidget(): Promise<void>;
	/**
	 * Shows trading properties
	 */
	showTradingProperties(): void;
	/**
	 * Returns symbol `minTick`.
	 * @param  {string} symbol - symbol identifier
	 */
	getSymbolMinTick(symbol: string): Promise<number>;
	/**
	 * Displays a message dialog to a user.
	 * @param  {string} title - title of the message dialog
	 * @param  {string} text - message
	 * @param  {boolean} textHasHTML? - whether message text contains HTML
	 */
	showMessageDialog(title: string, text: string, textHasHTML?: boolean): void;
	/**
	 * Displays a confirmation dialog to a user and returns a Promise to the result.
	 * @param  {string} title - title of the confirmation dialog
	 * @param  {string|string[]} content - content for the dialog
	 * @param  {string} mainButtonText? - text for the main button (`true` result)
	 * @param  {string} cancelButtonText? - text for the cancel button (`false` result)
	 * @param  {boolean} showDisableConfirmationsCheckbox? - show disable confirmations checkbox within the dialog
	 */
	showConfirmDialog(title: string, content: string | string[], mainButtonText?: string, cancelButtonText?: string, showDisableConfirmationsCheckbox?: boolean): Promise<boolean>;
	/**
	 * Displays a simple confirmation dialog to a user and returns a Promise to the result.
	 * @param  {string} title - title of the confirmation dialog
	 * @param  {string|string[]} content - content for the dialog
	 * @param  {string} mainButtonText? - text for the main button (`true` result)
	 * @param  {string} cancelButtonText? - text for the cancel button (`false` result)
	 * @param  {boolean} showDisableConfirmationsCheckbox? - show disable confirmations checkbox within the dialog
	 */
	showSimpleConfirmDialog(title: string, content: string | string[], mainButtonText?: string, cancelButtonText?: string, showDisableConfirmationsCheckbox?: boolean): Promise<boolean>;
}
export interface IBrokerTerminal extends IBrokerWithoutRealtime {
	/**
	 * Library is requesting that realtime updates should be supplied for this symbol.
	 * @param  {string} symbol - symbol identifier
	 */
	subscribeRealtime(symbol: string): void;
	/**
	 * Library is notifying that realtime updates are no longer required for this symbol.
	 * @param  {string} symbol - symbol identifier
	 */
	unsubscribeRealtime(symbol: string): void;
}
export interface IBrokerWithoutRealtime extends IBrokerCommon {
	/**
	 * Library is requesting that realtime DOM (Depth of Market) updates should be supplied for this symbol
	 * @param  {string} symbol - symbol identifier
	 */
	subscribeDOME?(symbol: string): void;
	/**
	 * Library is notifying that realtime DOM (Depth of Market) updates are no longer required for this symbol.
	 * @param  {string} symbol - symbol identifier
	 */
	unsubscribeDOME?(symbol: string): void;
	/**
	 * Method is called when a user wants to place an order. Order is pre-filled with partial or complete information. This function returns an object with the order id.
	 * @param  {PreOrder} order - order information
	 * @param  {string} confirmId? - is passed if `supportPlaceOrderPreview` configuration flag is on.
	 * @returns PlaceOrderResult, which should include an `orderId`
	 */
	placeOrder(order: PreOrder, confirmId?: string): Promise<PlaceOrderResult>;
	/**
	 * Returns estimated commission, fees, margin and other information for the order without it actually being placed.
	 * The method is called if `supportPlaceOrderPreview` configuration flag is on.
	 * @param  {PreOrder} order - order information
	 */
	previewOrder?(order: PreOrder): Promise<OrderPreviewResult>;
	/**
	 * Method is called when a user wants to modify an existing order.
	 * @param  {Order} order - order information
	 * @param  {string} confirmId? - is passed if `supportPlaceOrderPreview` configuration flag is on.
	 */
	modifyOrder(order: Order, confirmId?: string): Promise<void>;
	/**
	 * This method is called to cancel a single order with the given `id`.
	 * @param  {string} orderId - id for the order to cancel
	 */
	cancelOrder(orderId: string): Promise<void>;
	/**
	 * This method is called to cancel multiple orders for a `symbol` and `side`.
	 *
	 * `ordersIds` parameter should contain the list of order ids to be cancelled.
	 * @param  {string} symbol - symbol identifier
	 * @param  {Side|undefined} side - order side
	 * @param  {string[]} ordersIds - ids already collected by `symbol` and `side`
	 */
	cancelOrders(symbol: string, side: Side | undefined, ordersIds: string[]): Promise<void>;
	/**
	 * This method is called if `supportNativeReversePosition` configuration flag is on. It allows to reverse the position by id.
	 * @param  {string} positionId - position
	 */
	reversePosition?(positionId: string): Promise<void>;
	/**
	 * This method is called if `supportClosePosition` configuration flag is on. It allows to close the position by id.
	 * @param  {string} positionId - position id
	 * @param  {number} amount? - The amount is specified if `supportPartialClosePosition` is `true` and the user wants to close only part of the position.
	 */
	closePosition?(positionId: string, amount?: number): Promise<void>;
	/**
	 * This method is called if `supportCloseTrade` configuration flag is on. It allows to close the trade by id.
	 * @param  {string} tradeId - trade id
	 * @param  {number} amount? - The amount is specified if `supportPartialCloseTrade` is `true` and the user wants to close only part of the trade.
	 */
	closeTrade?(tradeId: string, amount?: number): Promise<void>;
	/**
	 * This method is called if `supportPositionBrackets` configuration flag is on. It shows a dialog that enables `take profit` and `stop loss` editing.
	 * @param  {string} positionId - is an ID of an existing position to be modified
	 * @param  {Brackets} brackets - new Brackets to be set for the position
	 * @param  {CustomInputFieldsValues} customFields? - custom fields to display in the dialog
	 */
	editPositionBrackets?(positionId: string, brackets: Brackets, customFields?: CustomInputFieldsValues): Promise<void>;
	/**
	 * This method is called if `supportTradeBrackets` configuration flag is on. It displays a dialog that enables take profit and stop loss editing.
	 * @param  {string} tradeId - ID of existing trade to be modified
	 * @param  {Brackets} brackets - new Brackets to be set for the trade
	 */
	editTradeBrackets?(tradeId: string, brackets: Brackets): Promise<void>;
	/**
	 * This method is called to receive leverageInfo from the broker.
	 * @param  {LeverageInfoParams} leverageInfoParams - information about the specific symbol to provide leverage info for
	 */
	leverageInfo?(leverageInfoParams: LeverageInfoParams): Promise<LeverageInfo>;
	/**
	 * This method is called to send user's leverage value to the broker. The value should be verified and corrected on the broker's side if required, and sent back in the response.
	 * @param  {LeverageSetParams} leverageSetParams - `leverageSetParams` is an object similar to {@link leverageInfoParams}, but contains an additional `leverage: number` field, which holds the leverage value set by the user.
	 */
	setLeverage?(leverageSetParams: LeverageSetParams): Promise<LeverageSetResult>;
	/**
	 * This method is called to receive {@link LeveragePreviewResult} object which holds messages about the leverage value set by the user.
	 * @param  {LeverageSetParams} leverageSetParams - `leverageSetParams` is an object similar to {@link leverageInfoParams}, but contains an additional `leverage: number` field, which holds the leverage value set by the user.
	 */
	previewLeverage?(leverageSetParams: LeverageSetParams): Promise<LeveragePreviewResult>;
	/**
	 * @deprecated Brokers should always send PL and equity updates
	 */
	subscribePL?(positionId: string): void;
	/**
	 * The method should be implemented if you use the standard Order dialog and support stop loss. Equity is used to calculate Risk in Percent.
	 *
	 * Once this method is called the broker should provide equity (Balance + P/L) updates via {@link IBrokerConnectionAdapterHost.equityUpdate} method.
	 */
	subscribeEquity?(): void;
	/**
	 * The method should be implemented if you use the standard Order dialog and want to show the margin meter.
	 *
	 * Once this method is called the broker should provide margin available updates via {@link IBrokerConnectionAdapterHost.marginAvailableUpdate} method.
	 * @param  {string} symbol - symbol identifier
	 */
	subscribeMarginAvailable?(symbol: string): void;
	/**
	 * The method should be implemented if you use a standard Order dialog.
	 * `pipValues` is displayed in the Order info and it is used to calculate the Trade Value and risks.
	 * If this method is not implemented then `pipValue` from the `symbolInfo` is used in the order panel/dialog.
	 *
	 * Once this method is called the broker should provide `pipValue` updates via {@link IBrokerConnectionAdapterHost.pipValueUpdate} method.
	 * @param  {string} symbol - symbol identifier
	 */
	subscribePipValue?(symbol: string): void;
	/**
	 * The method should be implemented if you use a standard Order dialog and implement `subscribePipValue`.
	 *
	 * Once this method is called the broker should stop providing `pipValue` updates.
	 * @param  {string} symbol - symbol identifier
	 */
	unsubscribePipValue?(symbol: string): void;
	/**
	 * The method should be implemented if you use the standard Order dialog want to show the margin meter.
	 *
	 * Once this method is called the broker should stop providing margin available updates.
	 * @param  {string} symbol - symbol identifier
	 */
	unsubscribeMarginAvailable?(symbol: string): void;
	/**
	 * @deprecated
	 */
	unsubscribePL?(positionId: string): void;
	/**
	 * The method should be implemented if you use the standard Order dialog and support stop loss.
	 *
	 * Once this method is called the broker should stop providing equity updates.
	 */
	unsubscribeEquity?(): void;
}
export interface IDelegate<TFunc extends Function> extends ISubscription<TFunc> {
	/** Fire (Evoke) */
	fire: TFunc;
}
/** Definition of a formatter */
export interface IFormatter<T> {
	/** Whatever the input type, formats the data following a certain logic and return that value as a string  */
	format(value?: T): string;
	/** Check if the input value satisfies the logic and return either an error or the result of the parsing  */
	parse?(value: string): ErrorFormatterParseResult | SuccessFormatterParseResult<T>;
}
export interface IObservable<T> {
	/**
	 * Subscribe to changes
	 * @param  {(value:T)=>void} callback - callback function to be evoked when observed value changes
	 */
	subscribe(callback: (value: T) => void): void;
	/**
	 * Unsubscribe from changes
	 * @param  {(value:T)=>void} callback - callback function to be unsubscribed
	 */
	unsubscribe(callback: (value: T) => void): void;
}
export interface IObservableValue<T> extends IBoxedValue<T>, IObservable<T> {
}
export interface IObservableValueReadOnly<T> extends IBoxedValueReadOnly<T>, IObservable<T> {
}
/**
 * Specific formatter for numbers
 */
export interface IPriceFormatter extends ISymbolValueFormatter {
	/**
	 * Price Formatter
	 * @param  {number} price - price
	 * @param  {boolean} signPositive? - add plus sign to result string.
	 * @param  {number} tailSize? - add `tailSize` digits to fractional part of result string
	 * @param  {boolean} signNegative? - add minus sign to result string.
	 * @param  {boolean} useRtlFormat? - Use Right to left format
	 * @param  {boolean} cutFractionalByPrecision? - cuts price by priceScalePrecision, without rounding.
	 * @returns formatted price
	 */
	format(price: number, signPositive?: boolean, tailSize?: number, signNegative?: boolean, useRtlFormat?: boolean, cutFractionalByPrecision?: boolean): string;
}
/**
 * A subscription. Used to subscribe callbacks to events.
 */
export interface ISubscription<TFunc extends Function> {
	/**
	 * Subscribe a callback function to this event. Subscribed callbacks are called when the event fires.
	 *
	 * @param obj Object used as the `this` value bound to the callback function.
	 * @param member Function called when the event is fired.
	 * @param singleshot `true` if the subscription should be automatically removed after the first time it is fired.
	 *
	 * @example
	 * ```
	 * // Log 'Series data loaded!' to the console the next time the data loaded event fires and then unsubscribe automatically.
	 * seriesApi.onDataLoaded().subscribe(null, () => { console.log('Series data loaded!'); }, true);
	 * ```
	 * Subscribe to an event within a class. Manually unsubscribe when some condition is true.
	 * ```
	 * class Example {
	 *   constructor(seriesApi) {
	 *     this._seriesApi = seriesApi;
	 *     this._seriesApi.onDataLoaded().subscribe(this, this._onDataLoaded);
	 *   }
	 *
	 *   _onDataLoaded() {
	 *     // Do something in response to the event.
	 *
	 *     if (someUnsubscribeCondition) {
	 *       this._seriesApi.onDataLoaded().unsubscribe(this, this._onDataLoaded);
	 *     }
	 *   }
	 * }
	 * ```
	 */
	subscribe(obj: object | null, member: TFunc, singleshot?: boolean): void;
	/**
	 * Unsubscribe a previously subscribed callback function.
	 * It is important that the `obj` and `member` arguments are the same as the ones passed when the callback was subscribed.
	 *
	 * @param obj Object passed as the `this` value when the callback was subscribed.
	 * @param member Function subscribed to the event.
	 */
	unsubscribe(obj: object | null, member: TFunc): void;
	/**
	 * Unsubscribe all callbacks that were subscribed with the same `obj` value.
	 *
	 * @param obj `obj` value passed when the callbacks were subscribed.
	 * @example
	 * ```
	 * // Unsubscribe all three callback functions at once in the `destroy` method.
	 * class Example {
	 *   constructor(seriesApi) {
	 *     this._seriesApi = seriesApi;
	 *     this._seriesApi.onDataLoaded().subscribe(this, this._callback1);
	 *     this._seriesApi.onDataLoaded().subscribe(this, this._callback2);
	 *     this._seriesApi.onDataLoaded().subscribe(this, this._callback3);
	 *   }
	 *
	 *   destroy() {
	 *     this._seriesapi.onDataLoaded().unsubscribeAll(this);
	 *   }
	 *
	 *   _callback1() { ... }
	 *   _callback2() { ... }
	 *   _callback3() { ... }
	 * }
	 * ```
	 */
	unsubscribeAll(obj: object | null): void;
}
export interface ISymbolValueFormatter {
	/** Default formatter function used to assign the correct sign (+ or -) to a number  */
	format(price: number, signPositive?: boolean): string;
}
export interface IWatchedValue<T> extends IWatchedValueReadonly<T>, IObservableValue<T> {
	/**
	 * Set value for the watched value
	 * @param  {T} value - value to set
	 * @param  {boolean} forceUpdate? - force an update
	 */
	setValue(value: T, forceUpdate?: boolean): void;
	/** @inheritDoc */
	subscribe(callback: WatchedValueCallback<T>, options?: WatchedValueSubscribeOptions): void;
	/** @inheritDoc */
	unsubscribe(callback?: WatchedValueCallback<T> | null): void;
}
export interface IWatchedValueReadonly<T> extends IObservableValueReadOnly<T> {
	/**
	 * Subscribe to watched value changes
	 * @param  {(value:T)=>void} callback - callback to be evoked when change occurs
	 * @param  {WatchedValueSubscribeOptions} options? - watch subscriber options
	 */
	subscribe(callback: (value: T) => void, options?: WatchedValueSubscribeOptions): void;
	/**
	 * Unsubscribe to watched value changes
	 * @param  {((value:T)=>void)|null} callback? - callback to remove
	 */
	unsubscribe(callback?: ((value: T) => void) | null): void;
	/**
	 * A simplified version of subscription, with promise-like interface, generally for using with boolean-valued watched values
	 * @param  {WatchedValueCallback<T>} callback - a function to be called when the value became `true`. `once` and `callWithLast` are implicitly set to true.
	 */
	when(callback: WatchedValueCallback<T>): void;
}
export interface InstrumentInfo {
	/** Quantity field step and boundaries */
	qty: QuantityMetainfo;
	/** Value of 1 pip for the instrument in the account currency */
	pipValue: number;
	/** Size of 1 pip (e.g., 0.0001 for EURUSD) */
	pipSize: number;
	/** Minimal price change (e.g., 0.00001 for EURUSD). Used for price fields. */
	minTick: number;
	/** Lot size */
	lotSize?: number;
	/** Instrument type. `forex` enables negative pips. You can check that in Order Ticket. */
	type?: SymbolType;
	/** Units of quantity or amount. Displayed instead of the Units label in the Quantity/Amount field. */
	units?: string;
	/** Display name for the symbol */
	brokerSymbol?: string;
	/** A description to be displayed in the UI dialogs. */
	description: string;
	/** Number of decimal places of DOM asks/bids volume (optional, 0 by default). */
	domVolumePrecision?: number;
	/** Leverage */
	leverage?: string;
	/**
	 * The margin requirement for the instrument. A 3% margin rate should be represented as 0.03.
	 * @deprecated
	 */
	marginRate?: number;
	/** Minimal price change for limit price field of the Limit and Stop Limit order. If set it will override the `minTick` value. */
	limitPriceStep?: number;
	/** Minimal price change for stop price field of the Stop and Stop Limit order. If set it will override the `minTick` value. */
	stopPriceStep?: number;
	/** Array of strings with valid duration values. You can check that in Order Ticket. */
	allowedDurations?: string[];
	/**
	 * Dynamic minimum price movement.
	 * It is used if the instrument's minimum price movement changes depending on the price range.
	 *
	 * For example: `0.01 10 0.02 25 0.05`, where `minTick` is `0.01` for a price less than `10`, `minTick` is `0.02` for a price less than `25`, `minTick` is `0.05` for a price more and equal than `25`.
	 */
	variableMinTick?: string;
	/** Instrument currency that is displayed in Order Ticket */
	currency?: string;
	/** The first currency quoted in a currency pair. Used for crypto currencies only. */
	baseCurrency?: string;
	/** The second currency quoted in a currency pair. Used for crypto currencies only. */
	quoteCurrency?: string;
	/** The value represented by a full point of price movement in the contract currency. This value is used to calculate the Total Value (symbol currency) of the order. */
	bigPointValue?: number;
	/** The value represents how much price is multiplied in relation to base monetary unit. */
	priceMagnifier?: number;
}
/** Show a custom message with the reason why the symbol cannot be traded */
export interface IsTradableResult {
	/**
	 * Is the symbol tradable
	 */
	tradable: boolean;
	/**
	 * Reason is displayed in Order Ticket
	 */
	reason?: string;
	/** Solution available to user to resolve the issue */
	solutions?: TradableSolutions;
	/** shortReason is displayed in the legend */
	shortReason?: string;
}
/**
 * An API object representing leverage info for an order.
 */
export interface LeverageInfo {
	/**
	 * The title for any Leverage Dialogs shown by the library.
	 */
	title: string;
	/**
	 * The leverage.
	 */
	leverage: number;
	/**
	 * The minimum leverage value.
	 */
	min: number;
	/**
	 * The maximum leverage value.
	 */
	max: number;
	/**
	 * The mimimum change between leverage values.
	 */
	step: number;
}
/**
 * An API object representing an order. Used when requesting leverage information from a broker.
 */
export interface LeverageInfoParams {
	/**
	 * The order symbol.
	 */
	symbol: string;
	/**
	 * The type of the order.
	 */
	orderType: OrderType;
	/**
	 * The order side. Buy or sell.
	 */
	side: Side;
	/**
	 * Custom data for the broker.
	 */
	customFields?: CustomInputFieldsValues;
}
/**
 * An API object representing some messages describing the leverage value set by the user.
 *
 * Shown in any Leverage Dialogs.
 */
export interface LeveragePreviewResult {
	/**
	 * Informative messages about the leverage value.
	 */
	infos?: string[];
	/**
	 * Warnings about the leverage value.
	 */
	warnings?: string[];
	/**
	 * Errors about the leverage value.
	 */
	errors?: string[];
}
/**
 * An API object representing an order and leverage. Used when requesting that a broker updates a order's leverage.
 */
export interface LeverageSetParams extends LeverageInfoParams {
	/**
	 * The requested leverage value.
	 */
	leverage: number;
}
/**
 * An API object representing a response containing the leverage value for a user.
 */
export interface LeverageSetResult {
	/**
	 * The leverage.
	 */
	leverage: number;
}
/** Separator for a dropdown or context menu */
export interface MenuSeparator extends ActionDescription {
	/** Is a menu separator */
	separator: boolean;
}
export interface NegativeBaseInputFieldValidatorResult extends BaseInputFieldValidatorResult {
	/** @inheritDoc */
	valid: false;
	/** Reason why base input value is invalid  */
	errorMessage: string;
}
export interface OrderDialogOptions extends TradingDialogOptions {
	/**
	 * Using this flag you can change `Trade Value` to `Total` in the Order Info section of the Order dialog.
	 */
	showTotal?: boolean;
}
export interface OrderDuration {
	/**
	 * type is OrderDurationMetaInfo.value
	 */
	type: string;
	/** Order duration time */
	datetime?: number;
}
/**
 * Expiration options for orders
 */
export interface OrderDurationMetaInfo {
	/** If it is set to `true`, then the Display date control in Order Ticket for this duration type will be displayed. */
	hasDatePicker?: boolean;
	/** If it is set to `true`, then the Display time control in Order Ticket for this duration type will be displayed. */
	hasTimePicker?: boolean;
	/**
	 * Default duration.
	 * Only one duration object in the durations array can have a `true` value for this field.
	 * The default duration will be used when the user places orders in the silent mode and it will be the selected one when the user opens Order Ticket for the first time.
	 */
	default?: boolean;
	/** Localized title of the duration. The title will be displayed in the Duration control of Order Ticket. */
	name: string;
	/** Duration identifier */
	value: string;
	/** A list of order types for which this duration type will be displayed in the Duration control of Order Ticket. Default value is `[OrderType.Limit, OrderType.Stop, OrderType.StopLimit]`. */
	supportedOrderTypes?: OrderType[];
}
export interface OrderOrPositionMessage {
	/** Type of message about the order or position */
	type: OrderOrPositionMessageType;
	/** Message content */
	text: string;
}
/** Describes the result of the order preview. */
export interface OrderPreviewResult {
	/** Order preview section */
	sections: OrderPreviewSection[];
	/** Confirmation ID. A unique identifier that should be passed to `placeOrder` method */
	confirmId?: string;
	/** Warning messages */
	warnings?: string[];
	/** Error messages */
	errors?: string[];
}
/**
 * Describes a single order preview section.
 * Order preview can have multiple sections that are divided by separators and may have titles.
 */
export interface OrderPreviewSection {
	/** Order preview items. Each item is a row of the section table. */
	rows: OrderPreviewSectionRow[];
	/** Optional title of the section. */
	header?: string;
}
/**
 * Describes a single row of a section table of the order preview.
 */
export interface OrderPreviewSectionRow {
	/** Description of the item. */
	title: string;
	/** Formatted value of the item. */
	value: string;
}
export interface OrderRule {
	/** Order ID */
	id: string;
	/** Severity of Order Rule */
	severity: "warning" | "error";
}
/**
 * Input value of the order ticket
 * This info is not sufficient to place an order
 */
export interface OrderTemplate {
	/** Symbol identifier */
	symbol: string;
	/** Order Type */
	type?: OrderType;
	/** order / execution side */
	side?: Side;
	/** Order quantity */
	qty?: number;
	/** Type of Stop Order */
	stopType?: StopType;
	/** Order stop price */
	stopPrice?: number;
	/** Order limit price */
	limitPrice?: number;
	/** Order Take Profit (Brackets) */
	takeProfit?: number;
	/** Order Stop loss (Brackets) */
	stopLoss?: number;
	/** Order Trailing stop (Brackets) */
	trailingStopPips?: number;
	/** Duration or expiration of an order */
	duration?: OrderDuration;
	/** Custom input fields */
	customFields?: CustomInputFieldsValues;
}
export interface PipValues {
	/** value of 1 pip if you buy */
	buyPipValue: number;
	/** value of 1 pip if you sell */
	sellPipValue: number;
}
export interface PlaceOrderResult {
	/** Order id */
	orderId?: string;
}
export interface PlacedOrder extends PlacedOrderBase, CustomFields {
}
/**
 * Info about a placed order
 */
export interface PlacedOrderBase {
	/** Order ID */
	id: string;
	/** Symbol name */
	symbol: string;
	/** Order type */
	type: OrderType;
	/** Order side (buy or sell) */
	side: Side;
	/** Order quantity (double) */
	qty: number;
	/** Order status */
	status: OrderStatus;
	/** Stop loss price (double). Available when Brackets are enabled */
	stopLoss?: number;
	/** Trailing stop Pips value (double). Available when Brackets are enabled */
	trailingStopPips?: number;
	/** Stop Loss type. It should be set to 1 (StopType.TrailingStop) for trailing stop orders. */
	stopType?: StopType;
	/** Take profit price (double). Available when Brackets are enabled */
	takeProfit?: number;
	/** Order duration */
	duration?: OrderDuration;
	/**
	 * An object that contains the results of broker specific user inputs (for example a digital signature).
	 * There are two possible kinds of custom fields: an input field with a checkbox and a custom combobox.
	 */
	customFields?: CustomInputFieldsValues;
	/** Filled order quantity (double) */
	filledQty?: number;
	/** Average fulfilled price for the order (double) */
	avgPrice?: number;
	/** Last update time (unix timestamp in milliseconds) */
	updateTime?: number;
	/** Price for the limit order (double) */
	limitPrice?: number;
	/** Price for the stop order (double) */
	stopPrice?: number;
	/** Message describing the state of the order */
	message?: OrderOrPositionMessage;
}
export interface Position extends PositionBase, CustomFields {
}
/**
 * Describes a single position.
 */
export interface PositionBase {
	/** Position ID. Usually id should be equal to brokerSymbol */
	id: string;
	/** Symbol name */
	symbol: string;
	/** Position Quantity (positive number) */
	qty: number;
	/** Short position quantity */
	shortQty?: number;
	/** Long position quantity */
	longQty?: number;
	/** Position Side */
	side: Side;
	/** Average price */
	avgPrice: number;
	/** Message describing the state of the position */
	message?: OrderOrPositionMessage;
}
export interface PositionDialogOptions extends TradingDialogOptions {
}
export interface PositiveBaseInputFieldValidatorResult extends BaseInputFieldValidatorResult {
	/** @inheritDoc */
	valid: true;
}
/**
 * Output value of the order ticket and input value of the broker's place order command
 * This info is sufficient to place an order
 */
export interface PreOrder extends OrderTemplate {
	/** @inheritDoc */
	symbol: string;
	/** @inheritDoc */
	type: OrderType;
	/** @inheritDoc */
	side: Side;
	/** @inheritDoc */
	qty: number;
	/** Current Quotes */
	currentQuotes?: AskBid;
	/**
	 * It is set to `true`, if the order closes a position.
	 */
	isClose?: boolean;
}
/**
 * Quantity field step and boundaries
 */
export interface QuantityMetainfo {
	/** Minimum quantity */
	min: number;
	/** Maximum quantity */
	max: number;
	/** Quantity step size */
	step: number;
	/** Quantity step size for scrolling */
	uiStep?: number;
	/** Default quantity value */
	default?: number;
}
export interface SingleBrokerMetaInfo {
	/**
	 * Broker Configuration Flags
	 */
	configFlags: BrokerConfigFlags;
	/**
	 * Optional field. You can use it if you have custom fields in orders or positions that should be taken into account when showing notifications.
	 *
	 * @example
	 * if you have field `additionalType` in orders and you want the chart to show a notification when it is changed, you should set:
	 * ```javascript
	 * customNotificationFields: ['additionalType']
	 * ```
	 */
	customNotificationFields?: string[];
	/**
	 * List of expiration options of orders. It is optional. Do not set it if you don't want the durations to be displayed in Order Ticket.
	 *
	 * The objects have the following keys: `{ name, value, hasDatePicker?, hasTimePicker?, default?, supportedOrderTypes? }`.
	 */
	durations?: OrderDurationMetaInfo[];
	/** Dialog options for Positions (order type) */
	positionDialogOptions?: PositionDialogOptions;
	/**
	 * Order Rules
	 */
	orderRules?: OrderRule[];
	/**
	 * This optional field can be used to replace the standard Order Ticket and the Add Protection dialogs with your own.
	 * Values of the following two fields are functions that are called by the Trading Terminal to show the dialogs. Each function shows a dialog and returns a `Promise` object that should be resolved when the operation is finished or cancelled.
	 *
	 * **NOTE:** The returned `Promise` object should be resolved with either `true` or `false` value.
	 *
	 * @example
	 * ```ts
	 * customUI: {
	 *     showOrderDialog?: (order: Order, focus?: OrderTicketFocusControl) => Promise<boolean>;
	 *     showPositionDialog?: (position: Position | Trade, brackets: Brackets, focus?: OrderTicketFocusControl) => Promise<boolean>;
	 *     showCancelOrderDialog?: (order: Order) => Promise<boolean>;
	 *     showClosePositionDialog?: (position: Position) => Promise<boolean>;
	 * }
	 * ```
	 */
	customUI?: BrokerCustomUI;
}
export interface SortingParameters {
	/** `property` of the data object that will be used for sorting */
	property: string;
	/** Ascending sorting order (default `true`) - If it is `false`, then initial sorting will be in descending order */
	asc?: boolean;
}
export interface StandardFormattersDependenciesMapping {
	[StandardFormatterName.Default]: string[];
	[StandardFormatterName.Symbol]: [
		brokerSymbolProperty: string,
		symbolProperty: string
	];
	[StandardFormatterName.Side]: [
		sideProperty: string
	];
	[StandardFormatterName.PositionSide]: [
		sideProperty: string
	];
	[StandardFormatterName.Text]: string[];
	[StandardFormatterName.Type]: [
		orderTypeProperty: string,
		parentIdProperty: string,
		stopTypeProperty: string
	];
	[StandardFormatterName.FormatPrice]: [
		priceProperty: string
	];
	[StandardFormatterName.FormatPriceForexSup]: [
		priceProperty: string
	];
	[StandardFormatterName.Status]: [
		statusProperty: string
	];
	[StandardFormatterName.Date]: [
		dateProperty: string
	];
	[StandardFormatterName.LocalDate]: [
		dateProperty: string
	];
	[StandardFormatterName.DateOrDateTime]: [
		dateProperty: string
	];
	[StandardFormatterName.LocalDateOrDateTime]: [
		dateProperty: string
	];
	[StandardFormatterName.Fixed]: [
		valueProperty: string
	];
	[StandardFormatterName.VariablePrecision]: [
		valueProperty: string
	];
	[StandardFormatterName.Pips]: [
		pipsProperty: string
	];
	[StandardFormatterName.IntegerSeparated]: [
		valueProperty: string
	];
	[StandardFormatterName.FormatQuantity]: [
		qtyProperty: string
	];
	[StandardFormatterName.Profit]: [
		profitProperty: string
	];
	[StandardFormatterName.ProfitInInstrumentCurrency]: [
		profitProperty: string,
		currencyProperty: string
	];
	[StandardFormatterName.Percentage]: [
		valueProperty: string
	];
	[StandardFormatterName.MarginPercent]: [
		valueProperty: string
	];
	[StandardFormatterName.Empty]: [
	];
}
export interface SuccessFormatterParseResult<T> extends FormatterParseResult {
	/** @inheritDoc */
	res: true;
	/** Returned value once parsing is done */
	value: T;
	/** Optional value returned by the default formatter */
	suggest?: string;
}
export interface TableFormatterInputs<T extends TableFormatterInputValues = TableFormatterInputValues> {
	/** Array of values to be formatted. Values are obtained by extracting dependent properties from the data object. */
	values: T extends [
		...args: infer A
	] ? [
		...A
	] : never;
	/** optional field. It is array of previous values so you can compare and format accordingly. It exists if current column has the `highlightDiff: true` key. */
	prevValues?: Partial<T extends [
		...args: infer A
	] ? [
		...A
	] : never>;
	/** standard formatter for price. You can use `format(price)` method to prepare price value. */
	priceFormatter?: INumberFormatter;
}
export interface TextWithCheckboxFieldCustomInfo {
	/** Title for the checkbox */
	checkboxTitle: string;
	/**
	 * Using `asterix` property you can manage input type.
	 * If `asterix` is set to `true` then a password input will be rendered.
	 */
	asterix?: boolean;
}
export interface TextWithCheckboxFieldMetaInfo extends CustomInputFieldMetaInfo {
	/** @inheritDoc */
	inputType: "TextWithCheckBox";
	/** @inheritDoc */
	value: TextWithCheckboxValue;
	/** @inheritDoc */
	customInfo: TextWithCheckboxFieldCustomInfo;
	/** @inheritDoc */
	validator?: TextInputFieldValidator;
}
export interface TextWithCheckboxValue {
	/** Checkbox text */
	text: string;
	/** Whether the checkbox is checked */
	checked: boolean;
}
export interface Trade extends TradeBase, CustomFields {
}
/**
 * Describes a single trade (individual position).
 */
export interface TradeBase {
	/** Trade ID. Usually id should be equal to brokerSymbol */
	id: string;
	/** Trade date (UNIX timestamp in milliseconds) */
	date: number;
	/** Symbol name */
	symbol: string;
	/** Trade Quantity */
	qty: number;
	/** Trade Side */
	side: Side;
	/** Trade price */
	price: number;
}
export interface TradeContext {
	/** Symbol name */
	symbol: string;
	/** Symbol display name */
	displaySymbol: string;
	/** Price value */
	value: number | null;
	/** Formatted value */
	formattedValue: string;
	/** Previous value */
	last: number;
}
export interface TradingDialogOptions {
	/** Custom fields to be displayed in the dialog (adds additional input fields to the Order dialog). */
	customFields?: TradingDialogCustomField[];
}
export interface TradingQuotes {
	/** Trade */
	trade?: number;
	/** Quote size */
	size?: number;
	/** Bid price */
	bid?: number;
	/** Bid quantity */
	bid_size?: number;
	/** Ask price */
	ask?: number;
	/** Ask quantity */
	ask_size?: number;
	/** Price spread */
	spread?: number;
	/** Whether quotes are delayed */
	isDelayed?: boolean;
	/** Whether quotes are halted */
	isHalted?: boolean;
	/** Whether quotes are hard to borrow */
	isHardToBorrow?: boolean;
	/** Whether quotes are can not be shorted */
	isNotShortable?: boolean;
}
export interface WatchedValueSubscribeOptions {
	/** Subscribe for only one update, and remove subscription afterwards. (the callback will be executed only once) */
	once?: boolean;
	/** if it is set to true then the callback will be executed with the previous value (if available) */
	callWithLast?: boolean;
}
export type AccountId = Nominal<string, "AccountID">;
export type AccountManagerColumn = {
	[K in StandardFormatterName | FormatterName]: AccountManagerColumnBase<K>;
}[StandardFormatterName | FormatterName];
/**
 * Describes a single action to put it into a dropdown or a context menu.
 */
export type ActionMetaInfo = ActionDescriptionWithCallback | MenuSeparator;
/**
 * The Ask and Bid quotes.
 */
export type AskBid = Required<Pick<TradingQuotes, "ask" | "bid">>;
export type CellAlignment = "left" | "right";
export type CustomFieldPossibleTypes = "TextWithCheckBox" | "ComboBox" | "Checkbox";
/**
 * A function that takes an {@link TableFormatterInputs} object and returns a `string` or an `HTMLElement`.
 */
export type CustomTableFormatElementFunction<T extends TableFormatterInputValues = TableFormatterInputValues> = (inputs: TableFormatterInputs<T>) => undefined | string | HTMLElement;
export type FormatterName = Nominal<string, "FormatterName">;
/** Specific formatter for number */
export type INumberFormatter = IFormatter<number>;
/**
 * Input field validator
 * @param  {any} value - value to be validated
 */
export type InputFieldValidator = (value: any) => InputFieldValidatorResult;
export type InputFieldValidatorResult = PositiveBaseInputFieldValidatorResult | NegativeBaseInputFieldValidatorResult;
export type LanguageCode = "ar" | "zh" | "cs" | "da_DK" | "ca_ES" | "nl_NL" | "en" | "et_EE" | "fr" | "de" | "el" | "he_IL" | "hu_HU" | "id_ID" | "it" | "ja" | "ko" | "fa" | "pl" | "pt" | "ro" | "ru" | "sk_SK" | "es" | "sv" | "th" | "tr" | "vi" | "no" | "ms_MY" | "zh_TW";
export type LeverageParams = LeverageInfoParams | LeverageSetParams;
export type Order = PlacedOrder | BracketOrder;
export type OrderTableColumn = AccountManagerColumn & {
	/**
	 * An optional numeric array of order statuses that is applied to order columns only. If it is available then the column will be displayed in the specified tabs of the status filter only.
	 *
	 * Here is the list of possible order statuses:
	 *
	 * 0 - All
	 * 1 - Canceled
	 * 2 - Filled
	 * 3 - Inactive
	 * 5 - Rejected,
	 * 6 - Working
	 */
	supportedStatusFilters?: OrderStatusFilter[];
};
export type SymbolType = "stock" | "index" | "forex" | "futures" | "bitcoin" | "crypto" | "undefined" | "expression" | "spread" | "cfd" | "economic" | "equity" | "dr" | "bond" | "right" | "warrant" | "fund" | "structured";
/**
 * A function that takes an {@link TableFormatterInputs} object and returns a `string`.
 */
export type TableFormatTextFunction<T extends TableFormatterInputValues = TableFormatterInputValues> = (inputs: TableFormatterInputs<T>) => string;
export type TableFormatterInputValue = any;
export type TableFormatterInputValues = TableFormatterInputValue[];
export type TextInputFieldValidator = (value: string) => InputFieldValidatorResult;
/**
 * `TradableSolutions` has one of the following keys:
 * - `changeAccount` - id of a sub-account suitable for trading the symbol
 * - `changeSymbol` - the symbol suitable for trading with current sub-account
 */
export type TradableSolutions = ChangeAccountSolution | ChangeSymbolSolution;
export type TradingDialogCustomField = CheckboxFieldMetaInfo | TextWithCheckboxFieldMetaInfo | CustomComboBoxMetaInfo;
export type WatchedValueCallback<T> = (value: T) => void;

export as namespace TradingView;

export {};
